<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #050505; 
            color: #FFB74D; 
            font-family: 'Segoe UI', 'Courier New', monospace; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            height: 100vh; 
            user-select: none;
        }
        .container {
            position: relative;
            width: 400px;
            height: 300px;
            border: 2px solid #FFB74D;
            border-radius: 10px;
            background: #000;
            box-shadow: 0 0 20px rgba(255, 183, 77, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* CRT Scanline effect */
        .container::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            border-radius: 10px;
        }
        canvas { 
            z-index: 1;
        }
        .status {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 14px;
            letter-spacing: 2px;
            text-shadow: 0 0 5px #FFB74D;
        }
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="c" width="380" height="240"></canvas>
        <div class="status">INITIALIZING... <span class="blink">_</span></div>
    </div>
    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d');
        
        // Cuboctahedron Vertices (Permutations of 0, 1, 1)
        const scale = 80;
        const vertices = [
            [0, 1, 1], [0, 1, -1], [0, -1, 1], [0, -1, -1],
            [1, 0, 1], [1, 0, -1], [-1, 0, 1], [-1, 0, -1],
            [1, 1, 0], [1, -1, 0], [-1, 1, 0], [-1, -1, 0]
        ].map(v => v.map(c => c * scale));

        // Simple distance check for edges
        const edges = [];
        for(let i=0; i<vertices.length; i++) {
            for(let j=i+1; j<vertices.length; j++) {
                const d2 = vertices[i].reduce((sum, c, k) => sum + Math.pow(c - vertices[j][k], 2), 0);
                // Distance between neighbors is sqrt(2)*scale. d^2 = 2*scale^2.
                if (Math.abs(d2 - 2*scale*scale) < 100) {
                    edges.push([i, j]);
                }
            }
        }

        let angX = 0, angY = 0;

        function draw() {
            // Clear with trail effect? No, crisp wireframe.
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, c.width, c.height);
            
            ctx.strokeStyle = '#FFB74D';
            ctx.lineWidth = 1.5;
            
            angX += 0.015;
            angY += 0.02;
            
            const cx = c.width / 2;
            const cy = c.height / 2;
            
            // Project
            const projected = vertices.map(v => {
                let x = v[0], y = v[1], z = v[2];
                
                // Rot X
                let ty = y*Math.cos(angX) - z*Math.sin(angX);
                let tz = y*Math.sin(angX) + z*Math.cos(angX);
                y = ty; z = tz;
                
                // Rot Y
                let tx = x*Math.cos(angY) - z*Math.sin(angY);
                tz = x*Math.sin(angY) + z*Math.cos(angY);
                x = tx; z = tz;
                
                // Perspective
                const fov = 300;
                const scaleP = fov / (fov + z + 200);
                return [cx + x * scaleP, cy + y * scaleP];
            });
            
            ctx.beginPath();
            for (let [i, j] of edges) {
                ctx.moveTo(projected[i][0], projected[i][1]);
                ctx.lineTo(projected[j][0], projected[j][1]);
            }
            ctx.stroke();
            
            // Draw vertices
            ctx.fillStyle = '#000';
            for (let p of projected) {
                ctx.beginPath();
                ctx.arc(p[0], p[1], 3, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();
            }

            requestAnimationFrame(draw);
        }
        draw();
    </script>
</body>
</html>
