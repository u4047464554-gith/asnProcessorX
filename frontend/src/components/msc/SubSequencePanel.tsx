import React, { useState, useCallback, useMemo } from 'react';
import { 
  Paper, 
  Stack, 
  Text, 
  List, 
  Button, 
  ActionIcon, 
  Group, 
  Badge, 
  ScrollArea, 
  Modal, 
  TextInput,
  NumberInput,
  Accordion 
} from '@mantine/core';
import { 
  IconPlus, 
  IconTrash, 
  IconGripVertical, 
  IconChevronDown, 
  IconChevronRight, 
  IconFolder, 
  IconFolderOpen,
  IconArrowsMoveVertical,
  IconEdit,
  IconRefresh
} from '@tabler/icons-react';
import type { MscSequence } from '../../domain/msc/types';
import { useMscEditor } from '../../hooks/useMscEditor';
import { MessageEditor } from './MessageEditor';

interface SubSequenceItem {
  id: string;
  name: string;
  sequence: MscSequence;
  isExpanded: boolean;
  depth: number;
  validationStatus: 'valid' | 'warning' | 'error';
  messageCount: number;
}

interface SubSequencePanelProps {
  sequence: MscSequence | null;
  onToggleExpand: (subId: string) => void;
  expandedSubSequences: Set<string>;
  height?: number;
}

export const SubSequencePanel: React.FC<SubSequencePanelProps> = ({
  sequence,
  onToggleExpand,
  expandedSubSequences,
  height = 300
}) => {
  const { state, addMessage, removeMessage, validateSequence } = useMscEditor();
  const [isAddingSubSequence, setIsAddingSubSequence] = useState(false);
  const [newSubName, setNewSubName] = useState('');
  const [editingSubSequence, setEditingSubSequence] = useState<MscSequence | null>(null);
  const [editingSubIndex, setEditingSubIndex] = useState<number | null>(null);
  const [draggedItem, setDraggedItem] = useState<string | null>(null);
  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);

  const subSequences = useMemo(() => {
    if (!sequence) return [];
    
    return sequence.subSequences.map((sub, index) => ({
      id: sub.id,
      name: sub.name,
      sequence: sub,
      isExpanded: expandedSubSequences.has(sub.id),
      depth: 0,
      validationStatus: sub.validationResults?.some(r => r.type === 'error') ? 'error' : 
                       sub.validationResults?.length > 0 ? 'warning' : 'valid',
      messageCount: sub.messages.length
    }));
  }, [sequence, expandedSubSequences]);

  const handleAddSubSequence = () => {
    if (!sequence) return;
    
    if (!newSubName.trim()) {
      alert('Sub-sequence name is required');
      return;
    }
    
    // Create new sub-sequence
    const newSubSequence = {
      id: '',  // Will be generated by backend
      name: newSubName,
      protocol: sequence.protocol,
      messages: [],
      subSequences: [],
      configurations: [],  // Inherit from parent
      validationResults: [],
      createdAt: new Date(),
      updatedAt: new Date()
    } as MscSequence;
    
    // Add to parent sequence (would need API call in full implementation)
    // For now, simulate local addition
    const updatedSequence = {
      ...sequence,
      subSequences: [...sequence.subSequences, newSubSequence]
    } as MscSequence;
    
    // In full implementation, this would be:
    // await addSubSequenceToSequence(sequence.id, newSubSequence);
    
    setNewSubName('');
    setIsAddingSubSequence(false);
    
    // Revalidate parent sequence
    validateSequence().catch(console.error);
  };

  const handleRemoveSubSequence = (subId: string) => {
    if (!sequence) return;
    
    if (!confirm(`Remove sub-sequence "${subId}"? This cannot be undone.`)) {
      return;
    }
    
    // Remove from parent sequence
    const updatedSequence = {
      ...sequence,
      subSequences: sequence.subSequences.filter(sub => sub.id !== subId)
    } as MscSequence;
    
    // In full implementation, this would be:
    // await removeSubSequenceFromSequence(sequence.id, subId);
    
    // Update expanded state
    onToggleExpand(subId);  // Close it when removing
    
    validateSequence().catch(console.error);
  };

  const handleToggleSubSequence = (subId: string) => {
    onToggleExpand(subId);
  };

  const handleEditSubSequence = (subSequence: MscSequence, index: number) => {
    setEditingSubSequence(subSequence);
    setEditingSubIndex(index);
  };

  const handleSaveSubSequence = (updatedSub: MscSequence) => {
    if (!sequence || editingSubIndex === null) {
      setEditingSubSequence(null);
      setEditingSubIndex(null);
      return;
    }
    
    // Update in parent sequence
    const updatedSequence = {
      ...sequence,
      subSequences: sequence.subSequences.map((sub, index) =>
        index === editingSubIndex ? updatedSub : sub
      )
    } as MscSequence;
    
    // In full implementation, update via API
    // await updateSubSequence(sequence.id, editingSubIndex, updatedSub);
    
    setEditingSubSequence(null);
    setEditingSubIndex(null);
    
    validateSequence().catch(console.error);
  };

  const moveSubSequence = (dragIndex: number, hoverIndex: number) => {
    if (!sequence || dragIndex === null || hoverIndex === null) return;
    
    const subSequences = [...sequence.subSequences];
    const [draggedSub] = subSequences.splice(dragIndex, 1);
    subSequences.splice(hoverIndex, 0, draggedSub);
    
    // In full implementation, update via API
    // await reorderSubSequences(sequence.id, subSequences.map(s => s.id));
    
    // Update local state
    // Note: This is simplified - would need to update the actual sequence state
    console.log('Sub-sequence moved from', dragIndex, 'to', hoverIndex);
  };

  const renderSubSequenceItem = (item: SubSequenceItem, index: number) => {
    const isDragging = draggedItem === item.id;
    const isDragOver = dragOverIndex === index;
    
    return (
      <div
        key={item.id}
        draggable
        onDragStart={(e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', item.id);
          setDraggedItem(item.id);
        }}
        onDragEnd={() => setDraggedItem(null)}
        onDragOver={(e) => {
          e.preventDefault();
          setDragOverIndex(index);
        }}
        onDragLeave={() => setDragOverIndex(null)}
        onDrop={(e) => {
          e.preventDefault();
          if (draggedItem && draggedItem !== item.id) {
            moveSubSequence(
              subSequences.findIndex(s => s.id === draggedItem),
              index
            );
          }
          setDragOverIndex(null);
        }}
        style={{
          padding: '12px',
          margin: '4px 0',
          border: '1px solid #e5e7eb',
          borderRadius: '6px',
          backgroundColor: isDragging ? '#f3f4f6' : 
                         isDragOver ? '#dbeafe' :
                         index % 2 === 0 ? '#f9fafb' : 'white',
          opacity: isDragging ? 0.5 : 1,
          transition: 'all 0.2s ease-in-out',
          cursor: 'move',
          borderLeft: isDragging ? '3px solid #3b82f6' : '1px solid #e5e7eb'
        }}
      >
        <Group justify="space-between">
          <Group gap="xs">
            <ActionIcon
              size="sm"
              variant="subtle"
              onClick={(e) => {
                e.stopPropagation();
                handleToggleSubSequence(item.id);
              }}
            >
              {expandedSubSequences.has(item.id) ? 
                <IconChevronDown size={14} /> : 
                <IconChevronRight size={14} />
              }
            </ActionIcon>
            
            <Group>
              <IconFolder 
                size={16} 
                color={item.validationStatus === 'error' ? '#ef4444' : 
                       item.validationStatus === 'warning' ? '#f59e0b' : '#10b981'} 
              />
              <Text size="sm" fw={500}>
                {item.name}
              </Text>
            </Group>
            
            <Badge 
              color={item.validationStatus}
              variant="light"
              size="sm"
            >
              {item.messageCount} messages
            </Badge>
          </Group>
          
          <Group gap="xs">
            <ActionIcon
              size="sm"
              variant="subtle"
              onClick={(e) => {
                e.stopPropagation();
                handleEditSubSequence(item.sequence, index);
              }}
            >
              <IconEdit size={14} />
            </ActionIcon>
            
            <ActionIcon
              size="sm"
              color="red"
              variant="subtle"
              onClick={(e) => {
                e.stopPropagation();
                handleRemoveSubSequence(item.id);
              }}
            >
              <IconTrash size={14} />
            </ActionIcon>
          </Group>
        </Group>
        
        {/* Sub-sequence stats */}
        <Group gap="xs" mt="xs" ml="20px">
          <Text size="xs" c="dimmed">
            Protocol: {item.sequence.protocol}
          </Text>
          <Text size="xs" c="dimmed">
            Created: {new Date(item.sequence.createdAt).toLocaleDateString()}
          </Text>
          {item.validationStatus !== 'valid' && (
            <Badge color={item.validationStatus} size="xs">
              {item.validationStatus.toUpperCase()}
            </Badge>
          )}
        </Group>
      </div>
    );
  };

  const renderSubSequenceEditor = () => {
    if (!editingSubSequence || editingSubIndex === null) {
      return null;
    }

    return (
      <Modal 
        opened={editingSubSequence !== null} 
        onClose={() => {
          setEditingSubSequence(null);
          setEditingSubIndex(null);
        }}
        title={`Edit Sub-Sequence: ${editingSubSequence.name}`}
        size="lg"
      >
        <Stack>
          <TextInput
            label="Sub-Sequence Name"
            value={editingSubSequence.name}
            onChange={(e) => {
              // Update local copy - would need to sync with parent
              console.log('Name changed to:', e.currentTarget.value);
            }}
            mb="md"
          />
          
          <ScrollArea h={400}>
            <Paper withBorder p="md" mt="md">
              <Text size="sm" fw={500} mb="md">Messages in this sub-sequence:</Text>
              <Stack gap="sm">
                {editingSubSequence.messages.map((message, index) => (
                  <Paper key={message.id} withBorder p="sm" shadow="xs">
                    <Group justify="apart">
                      <Text size="sm">{message.type}</Text>
                      <Group>
                        <ActionIcon size="xs" variant="subtle" color="blue">
                          <IconEdit size={12} />
                        </ActionIcon>
                        <ActionIcon size="xs" color="red" variant="subtle">
                          <IconTrash size={12} />
                        </ActionIcon>
                      </Group>
                    </Group>
                    <Text size="xs" c="dimmed" mt="xs">
                      From {message.sourceActor} to {message.targetActor}
                    </Text>
                  </Paper>
                ))}
              </Stack>
            </Paper>
            
            <Paper withBorder p="md" mt="md">
              <Group justify="apart" mb="md">
                <Text size="sm" fw={500}>Add Message to Sub-Sequence</Text>
                <Button size="xs" leftSection={<IconPlus size={14} />}>
                  Add
                </Button>
              </Group>
              
              <MessageEditor
                message={null}
                sequenceId={editingSubSequence.id}
                onSave={(message) => {
                  // Add message to sub-sequence
                  console.log('Add message to sub-sequence:', message);
                  setEditingSubSequence(null);
                  setEditingSubIndex(null);
                }}
                onCancel={() => setEditingSubSequence(null)}
                isNew={true}
                availableTypes={editingSubSequence.messages.map(m => m.type_name)}
              />
            </Paper>
          </ScrollArea>
          
          <Group justify="flex-end" mt="md">
            <Button 
              variant="subtle" 
              onClick={() => setEditingSubSequence(null)}
            >
              Cancel
            </Button>
            <Button 
              onClick={() => {
                // Save sub-sequence changes
                if (editingSubSequence) {
                  handleSaveSubSequence(editingSubSequence);
                }
              }}
            >
              Save Sub-Sequence
            </Button>
          </Group>
        </Stack>
      </Modal>
    );
  };

  if (!sequence) {
    return (
      <Paper p="md" withBorder>
        <Group>
          <IconFolder size={24} color="gray" />
          <Text c="dimmed">No sequence loaded</Text>
        </Group>
      </Paper>
    );
  }

  return (
    <Paper withBorder p="md" style={{ height, overflow: 'hidden' }}>
      <Group justify="space-between" mb="md">
        <Text size="lg" fw={600}>Sub-Sequences</Text>
        <Group>
          <Button 
            leftSection={<IconPlus size={14} />}
            onClick={() => setIsAddingSubSequence(!isAddingSubSequence)}
            size="sm"
            variant="light"
          >
            Add Sub-Sequence
          </Button>
          <Button 
            leftSection={<IconRefresh size={14} />}
            onClick={validateSequence}
            size="sm"
            variant="subtle"
            disabled={state.isValidating}
          >
            Validate All
          </Button>
        </Group>
      </Group>

      {/* Add Sub-Sequence Form */}
      {isAddingSubSequence && (
        <Paper withBorder p="md" mb="md" shadow="xs">
          <Stack gap="sm">
            <Text size="sm" fw={500}>New Sub-Sequence</Text>
            <TextInput
              placeholder="Enter sub-sequence name"
              value={newSubName}
              onChange={(e) => setNewSubName(e.currentTarget.value)}
              size="md"
            />
            <Group justify="flex-end">
              <Button 
                variant="subtle" 
                onClick={() => setIsAddingSubSequence(false)}
                size="sm"
              >
                Cancel
              </Button>
              <Button 
                onClick={handleAddSubSequence}
                disabled={!newSubName.trim()}
                size="sm"
              >
                Create
              </Button>
            </Group>
          </Stack>
        </Paper>
      )}

      {/* Sub-Sequence List */}
      <ScrollArea h={height - 120} styles={(theme) => ({
        root: { border: `1px solid ${theme.colors.gray[3]}` }
      })}>
        <Stack gap="md">
          {subSequences.length === 0 ? (
            <Text c="dimmed" ta="center" p="md">
              No sub-sequences. Add sub-sequences to organize complex message flows.
            </Text>
          ) : (
            subSequences.map((item, index) => renderSubSequenceItem(item, index))
          )}
        </Stack>
      </ScrollArea>

      {/* Render sub-sequence editor modal */}
      {renderSubSequenceEditor()}
    </Paper>
  );
};

SubSequencePanel.displayName = 'SubSequencePanel';

export default SubSequencePanel;
